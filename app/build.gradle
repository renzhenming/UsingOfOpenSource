import com.plugin.patch.Patch
import org.apache.commons.compress.utils.IOUtils
import org.objectweb.asm.AnnotationVisitor
import org.objectweb.asm.ClassReader
import org.objectweb.asm.ClassVisitor
import org.objectweb.asm.ClassWriter
import org.objectweb.asm.FieldVisitor
import org.objectweb.asm.MethodVisitor
import org.objectweb.asm.Opcodes
import org.objectweb.asm.Type
import org.objectweb.asm.commons.AdviceAdapter
import org.objectweb.asm.commons.Method

import java.util.jar.JarEntry
import java.util.jar.JarFile
import java.util.jar.JarOutputStream

plugins {
    id 'com.android.application'

    //TODO 编译没有通过 先放着吧
//    id 'com.didi.dokit'
    id 'androidx.benchmark'
}

plugins {
    //id指的就是resources.META-INF.gradle.plugins中的文件名"com.plugin.patch"
    id 'com.plugin.patch'
    id 'org.jetbrains.kotlin.android'
}

patch {
    debugOn true
    applicationName "com.rzm.testapplication"
}
apply from: 'argusapm.gradle'
//apply plugin: 'argusapm'

android {
    compileSdkVersion 30
    buildToolsVersion "30.0.3"

    //在android的配置代码块里面(为了兼容Android6.0系统):
    useLibrary 'org.apache.http.legacy'

    defaultConfig {
        applicationId "com.rzm.testapplication"
        minSdkVersion 22
        targetSdkVersion 30
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"

        javaCompileOptions {
            annotationProcessorOptions {
                arguments = [AROUTER_MODULE_NAME: project.getName()]
            }
        }

        dataBinding.enabled = true
//        TODO 开启就编译失败了，先不管了
//        viewBinding {
//            enabled = true
//        }

        externalNativeBuild {
            cmake {
                cppFlags ""
            }
        }
    }

    buildTypes {
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }

        debug {
//            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    externalNativeBuild {
        cmake {
            path "src/main/cpp/CMakeLists.txt"
            version "3.10.2"
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    /**
     * 当项目中依赖的第三方库越来越多时，有可能会出现两个依赖库中存在同一个（名称）文件。如果这样，Gradle在打包时就会提示错误（警告）。
     * 那么就可以根据提示，然后使用以下方法将重复的文件剔除，比较常用的是通过exclude去除重复的文件，例如：
     */
    packagingOptions {
        exclude 'META-INF/*******'
        exclude 'META-INF/INDEX.LIST'
        exclude 'META-INF/io.netty.versions.properties'
    }
}

//TODO 编译没有通过 先放着吧
//dokit
//dokitExt {
//    //通用设置
//    comm {
//        //地图经纬度开关
//        gpsSwitch true
//        //网络开关
//        networkSwitch true
//        //大图开关
//        bigImgSwitch true
//        //webView js 抓包
//        webViewSwitch true
//    }
//
//    slowMethod {
//        //调用栈模式配置 对应gradle.properties中DOKIT_METHOD_STRATEGY=0
//        stackMethod {
//            //默认值为 5ms 小于该值的函数在调用栈中不显示
//            thresholdTime 10
//            //调用栈函数入口 千万不要用我默认的配置 如果有特殊需求修改成项目中自己的入口 假如不需要可以去掉该字段
//            //enterMethods = ["com.didichuxing.doraemondemo.MainDebugActivity.test1"]
//            //黑名单 粒度最小到类 暂不支持到方法  千万不要用我默认的配置 如果有特殊需求修改成项目中自己的入口 假如不需要可以去掉该字段
//            //methodBlacklist = ["com.facebook.drawee.backends.pipeline.Fresco"]
//        }
//        //普通模式配置 对应gradle.properties中DOKIT_METHOD_STRATEGY=1
//        normalMethod {
//            //默认值为 500ms 小于该值的函数在运行时不会在控制台中被打印
//            thresholdTime 500
//            //需要针对函数插装的包名 千万不要用我默认的配置 如果有特殊需求修改成项目中自己的项目包名 假如不需要可以去掉该字段
//            //packageNames = ["com.didichuxing.doraemondemo"]
//            //不需要针对函数插装的包名&类名 千万不要用我默认的配置 如果有特殊需求修改成项目中自己的项目包名 假如不需要可以去掉该字段
//            //methodBlacklist = ["com.didichuxing.doraemondemo.dokit"]
//        }
//    }
//}

dependencies {

    implementation 'androidx.appcompat:appcompat:1.0.0'
    implementation 'com.google.android.material:material:1.1.0-alpha02'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.3'
    implementation 'androidx.legacy:legacy-support-v4:1.0.0'
    testImplementation 'junit:junit:4.+'
    androidTestImplementation 'androidx.test.ext:junit:1.1.3'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'

    //OkHttp
    implementation("com.squareup.okhttp3:okhttp:4.9.3")

    //Glide
    implementation 'com.github.bumptech.glide:glide:4.13.0'

    //Retrofit
    implementation 'com.squareup.retrofit2:retrofit:2.9.0'
    implementation 'com.squareup.retrofit2:converter-gson:2.7.0'

    //ARouter
    implementation 'com.alibaba:arouter-api:1.5.1'
    annotationProcessor 'com.alibaba:arouter-compiler:1.5.1'

    //ASM
    testImplementation("org.ow2.asm:asm:7.1")
    testImplementation("org.ow2.asm:asm-commons:7.1")

    //LeakCanary
    // debugImplementation because LeakCanary should only run in debug builds.
    debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0'


    implementation 'com.github.renzhenming:CrashHanlder:1.0.0'

    //ProcessLifecycleOwner需要用到
    //implementation 'androidx.lifecycle:lifecycle-extensions:2.2.0'
    // 过时方式（lifecycle-extensions 不再维护）
    //implementation "androidx.lifecycle:lifecycle-extensions:2.4.0"

    // 目前的方式：
    def lifecycle_version = "2.5.0"

    // Lifecycle 核心类
    implementation "androidx.lifecycle:lifecycle-runtime:$lifecycle_version"
    // Lifecycle 注解处理器（用于处理 @OnLifecycleEvent 注解）
    annotationProcessor "androidx.lifecycle:lifecycle-compiler:$lifecycle_version"
    implementation "androidx.lifecycle:lifecycle-common-java8:$lifecycle_version"
    // 应用进程级别 Lifecycle
    implementation "androidx.lifecycle:lifecycle-process:$lifecycle_version"

    // LiveData
    implementation "androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version"
    // ViewModel
    implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version"


    //android-startup
    implementation 'io.github.idisfkj:android-startup:1.1.0'

    implementation 'androidx.startup:startup-runtime:1.1.1'

    //alibaba 启动框架alpha
//    implementation 'com.alibaba.android:alpha:1.0.0.1@aar'


    //blockcanary
    implementation 'com.github.markzhai:blockcanary-android:1.5.0'

    //anrwatchdog
    implementation 'com.github.anrwatchdog:anrwatchdog:1.4.0'

    //koom
    implementation "com.kuaishou.koom:koom-java-leak:2.2.0"
    implementation "com.kuaishou.koom:koom-monitor-base:2.2.0"

    //websocket
    //implementation "org.java-websocket:Java-WebSocket:1.5.1"
    implementation project(path: ':websocketlib')

    //dokit
    //TODO 编译没有通过 先放着吧
    //TODO Execution failed for task ':app:processDebugManifest'.
    //TODO org.xml.sax.SAXParseException; systemId: file:/Users/renzhenming/AndroidStudioProjects/TestApplication/app/build/intermediates/merged_manifests/debug/; lineNumber: 1; columnNumber: 1; 前言中不允许有内容。
//    debugImplementation "io.github.didi.dokit:dokitx:3.5.0"

//    // 仅在debug包启用BlockCanary进行卡顿监控和提示的话，可以这么用
//    debugImplementation 'com.github.markzhai:blockcanary-android:1.5.0'
//    releaseImplementation 'com.github.markzhai:blockcanary-no-op:1.5.0'
}
//gradle执行会解析build.gradle文件，afterEvaluate表示在解析完成之后再执行我们的代码
//afterEvaluate {
//    android.getApplicationVariants().all { variant ->
//        String variantName = variant.name
//        String capitalizedName = variantName.capitalize()
//        println("---------variants = " + variantName + " capitalizedName = " + capitalizedName)
//        //这就是打包时，把jar和class打包成dex的任务
//        Task dexTask = project.getTasks().findByName("transformClassesWithDexBuilderFor" + capitalizedName)
//        println("---------variants = " + variantName + " transformClassesWithDexBuilderFor = " + dexTask)
//        if (dexTask != null) {
//            //在生成dex之前执行插桩
//            dexTask.doFirst {
//                FileCollection fileCollection = dexTask.getInputs().getFiles()
//
//                for (File file : fileCollection) {
//                    println("---------file = " + file.getName())
//                    String filePath = file.getAbsolutePath()
//                    if (filePath.endsWith(".jar")) {
//                        //依赖的库会以jar包形式传过来，对依赖库也执行插桩
////                    processJar(file)
//                    } else if (filePath.endsWith(".class")) {
//                        //主要是我们自己写的app模块中的代码
//                        processClass(variant.getDirName(), file)
//                    }
//                }
//            }
//        }
//    }
//}
//
//static void processJar(File file) {
//    try {
//        //  无论是windows还是linux jar包都是 /
//        File bakJar = new File(file.getParent(), file.getName() + ".bak");
//        JarOutputStream jarOutputStream = new JarOutputStream(new FileOutputStream(bakJar));
//
//        JarFile jarFile = new JarFile(file);
//        Enumeration<JarEntry> entries = jarFile.entries();
//        while (entries.hasMoreElements()) {
//            JarEntry jarEntry = entries.nextElement();
//
//            // 读jar包中的一个文件 ：class
//            jarOutputStream.putNextEntry(new JarEntry(jarEntry.getName()));
//            InputStream is = jarFile.getInputStream(jarEntry);
//
//            String className = jarEntry.getName();
//            println("---------processJar = " + className)
//            if (className.endsWith(".class") && !className.startsWith("com/rzm/testapplication/Application")
//                    && !isAndroidClass(className)) {
//                byte[] byteCode = doWithAsm(is, className);
//                jarOutputStream.write(byteCode);
//            } else {
//                //输出到临时文件
//                jarOutputStream.write(IOUtils.toByteArray(is));
//            }
//            jarOutputStream.closeEntry();
//        }
//        jarOutputStream.close();
//        jarFile.close();
//        file.delete();
//        bakJar.renameTo(file);
//    } catch (IOException e) {
//        e.printStackTrace();
//    }
//}
//
//static void processClass(String dirName, File file) {
//    //注意这里的filePath包含了目录+包名+类名，所以去掉目录
//    ///Users/renzhenming/AndroidStudioProjects/TestApplication/app/build/intermediates/javac/debug/classes/com/rzm/testapplication/okhttp/OkHttpActivity.class
//    String filePath = file.getAbsolutePath()
//    println("---------processClass dirName = " + dirName + " filePath = " + filePath)
//
//    //className = classes/com/rzm/testapplication/retrofit/User.class
//    dirName = dirName + "/classes"
//    String className = filePath.split(dirName)[1].substring(1);
//    println("---------processClass dirName = " + dirName + " filePath = " + filePath + " \n className = " + className)
//
//    //com.rzm.testapplication.Application
//    if (className.startsWith("com/rzm/testapplication/Application") || isAndroidClass(className)) {
//        println("---------processClass className = " + className + " return")
//        return
//    }
//
//    try {
//        FileInputStream is = new FileInputStream(filePath)
//
//        byte[] bytes = doWithAsm(is, className)
//
//        FileOutputStream fos = new FileOutputStream(filePath)
//        fos.write(bytes)
//        fos.close()
//    } catch (Exception e) {
//        e.printStackTrace()
//    }
//}
//
//static byte[] doWithAsm(InputStream inputStream, String className) {
//    ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES)
//    ClassReader cr = new ClassReader(inputStream)
//
//    ClassVisitor cv = new ClassVisitor(Opcodes.ASM5, cw) {
//        @Override
//        public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
//            println("---------access = " + access + " name = " + name + " descriptor = " + descriptor + " signature = " + signature + " exceptions = " + exceptions);
//            MethodVisitor methodVisitor = super.visitMethod(access, name, descriptor, signature, exceptions);
//            MyMethodVisitor myMethodVisitor = new MyMethodVisitor(Opcodes.ASM5, methodVisitor, access, name, descriptor, className);
//            return myMethodVisitor
//        }
//
//        @Override
//        FieldVisitor visitField(int access, String name, String desc, String signature, Object value) {
//            return super.visitField(access, name, desc, signature, value)
//        }
//
//        @Override
//        void visitAttribute(org.objectweb.asm.Attribute attr) {
//            super.visitAttribute(attr)
//        }
//
//        @Override
//        void visitInnerClass(String name, String outerName, String innerName, int access) {
//            super.visitInnerClass(name, outerName, innerName, access)
//        }
//
//        @Override
//        AnnotationVisitor visitAnnotation(String desc, boolean visible) {
//            return super.visitAnnotation(desc, visible)
//        }
//    };
//
//    cr.accept(cv, ClassReader.EXPAND_FRAMES)
//
//    byte[] bytes = cw.toByteArray()

//    return bytes
//}
//
//class MyMethodVisitor extends AdviceAdapter {
//
//    private int start
//    private String className
//    private String methodName
//
//    protected MyMethodVisitor(int api, MethodVisitor methodVisitor, int access, String name, String descriptor, String className) {
//        super(api, methodVisitor, access, name, descriptor)
//        this.className = className
//        this.methodName = name
//    }
//
//    @Override
//    protected void onMethodEnter() {
//        super.onMethodEnter()
//        //long start = System.currentTimeMillis()
//        invokeStatic(Type.getType("Ljava/lang/System;"), new Method("currentTimeMillis", "()J"))
//        start = newLocal(Type.LONG_TYPE)
//        storeLocal(start)
//    }
//
//    /**
//     * 生成
//     * long end = System.currentTimeMillis();
//     * System.out.println("consume = " + (end - start));
//     *
//     * @param opcode
//     */
//    @Override
//    protected void onMethodExit(int opcode) {
//        super.onMethodExit(opcode);
//        //long end = System.currentTimeMillis();
//        //18: invokestatic  #5                  // Method java/lang/System.currentTimeMillis:()J
//        invokeStatic(Type.getType("Ljava/lang/System;"), new Method("currentTimeMillis", "()J"));
//        //21: lstore_3
//        int end = newLocal(Type.LONG_TYPE);
//        storeLocal(end);
//
//        //获取System的静态方法out,out的类型是PrintStream
//        //22: getstatic     #11                 // Field java/lang/System.out:Ljava/io/PrintStream;
//        getStatic(Type.getType("Ljava/lang/System;"), "out", Type.getType("Ljava/io/PrintStream;"));
//
//        //拼接字符串，底层用的StringBuilder
//        //25: new           #12                 // class java/lang/StringBuilder
//        newInstance(Type.getType("Ljava/lang/StringBuilder;"));
//
//        //28: dup
//        dup();
//
//        //29: invokespecial #13                 // Method java/lang/StringBuilder."<init>":()V
//        invokeConstructor(Type.getType("Ljava/lang/StringBuilder;"), new Method("<init>", "()V"));
//
//        //32: ldc           #14                 // String consume =
//        visitLdcInsn(className + " method: " + methodName + ", consume = ");
//
//        //34: invokevirtual #15                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
//        invokeVirtual(Type.getType("Ljava/lang/StringBuilder;"), new Method("append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;"));
//
//        //37: lload_3
//        loadLocal(end);
//
//        //38: lload_1
//        loadLocal(start);
//
//        //39: lsub
//        math(SUB, Type.LONG_TYPE);
//
//        //40: invokevirtual #16                 // Method java/lang/StringBuilder.append:(J)Ljava/lang/StringBuilder;
//        invokeVirtual(Type.getType("Ljava/lang/StringBuilder;"), new Method("append", "(J)Ljava/lang/StringBuilder;"));
//
//        //43: invokevirtual #17                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
//        invokeVirtual(Type.getType("Ljava/lang/StringBuilder;"), new Method("toString", "()Ljava/lang/String;"));
//
//        //46: invokevirtual #18                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
//        invokeVirtual(Type.getType("Ljava/io/PrintStream;"), new Method("println", "(Ljava/lang/String;)V"));
//    }
//}
//
//
//static boolean isAndroidClass(String filePath) {
//    return filePath.startsWith("android") ||
//            filePath.startsWith("androidx");
//}